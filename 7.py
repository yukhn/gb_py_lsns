# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора
# класса (метод __init__()), который должен принимать данные (список 
# списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, 
# расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.

# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8

# Следующий шаг — реализовать перегрузку метода __str__() для вывода 
# матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции
# сложения двух объектов класса Matrix (двух матриц). Результатом сложения
# должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый
# элемент первой строки первой матрицы складываем с первым элементом первой
# строки второй матрицы и т.д.

class Matrix:
    def __init__(self, lists, switch):
        self.lists = lists
        self.switch = switch

    def __str__(self):
# Вывод матрицы, при вводе 0 - построчно, 1 - по столбцам
        if self.switch == 0:
            for i in self.lists:
                print(" ".join(map(str, i)))
        elif self.switch == 1:
            x = [[i[x] for i in self.lists] for x in range(len(self.lists[0]))]
            for i in x:
                print(" ".join(map(str, i)))
        print("---------")
            
    def __add__(self, other):
        res = [[self.lists[i][j] + other.lists[i][j] for j in range(len(self.lists[0]))] for i in range(len(self.lists))]
        for i in res:
            print(" ".join(map(str, i)))
        print("---------")
            
m1_str = Matrix([[31, 32], [37, 43], [51, 86]], 0)
m1_clm = Matrix([[31, 32], [37, 43], [51, 86]], 1)
m2_str = Matrix([[3, 5, 32], [2, 4, 46], [-1, 64, 8]], 0)
m2_clm = Matrix([[3, 5, 32], [2, 4, 46], [-1, 64, 8]], 1)
m3 = Matrix([[3, 5, 8, 3], [8, 3, 7, 1]], 0)

m1_str.__str__()
m1_clm.__str__()
m2_str.__str__()
m2_clm.__str__()

m1_str.__add__(m1_str)
m3.__add__(m3)
new_m = m2_str + m2_str
new_m

# 2. Реализовать проект расчёта суммарного расхода ткани на производство 
# одежды. Основная сущность (класс) этого проекта — одежда, которая может
# иметь определённое название. К типам одежды в этом проекте относятся 
# пальто и костюм. У этих типов одежды существуют параметры: размер 
# (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H,
# соответственно.
# Для определения расхода ткани по каждому типу одежды использовать 
# формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). Проверить
# работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные
# на этом уроке знания: реализовать абстрактные классы для основных классов 
# проекта, проверить на практике работу декоратора @property.

from abc import ABC, abstractmethod

class Clothes(ABC):
    def __init__(self, size, title):
        self.title = title
        self.size = size

    @property
    def size(self):
        return f"Для одежды вида {self.title} нужно {round(self.__size, 2)} м ткани"
        
    @size.setter
    def size(self, size):
        if self.title == "костюм":
            self.__size = 2 * size + 0.3
        if self.title == "пальто":
            self.__size = size / 6.5 + 0.3
    
    @abstractmethod
    def get_title(self):
        pass
    
class Suit(Clothes):
    def __init__(self, size, title="костюм"):
        super().__init__(size, title)
        
    def get_title(self):
        return f"Это {self.title}"

class Coat(Clothes):
    def __init__(self, size, title="пальто"):
        super().__init__(size, title)
        
    def get_title(self):
        return f"Это абстрактный метод"

suit = Suit(176)    
coat = Coat(48)
print(suit.get_title() + "\n" + coat.get_title())
print(suit.size + "\n" + coat.size)

# 3. Реализовать программу работы с органическими клетками, состоящими из 
# ячеек. Необходимо создать класс Клетка. В его конструкторе 
# инициализировать параметр, соответствующий количеству ячеек клетки 
# (целое число). В классе должны быть реализованы методы перегрузки 
# арифметических операторов: сложение (__add__()), вычитание (__sub__()),
# умножение (__mul__()), деление (__truediv__()). Данные методы должны
# применяться только к клеткам и выполнять увеличение, уменьшение, 
# умножение и целочисленное (с округлением до целого) деление клеток, 
# соответственно.

# Сложение. Объединение двух клеток. При этом число ячеек общей клетки 
# должно равняться сумме ячеек исходных двух клеток.

# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только 
# если разность количества ячеек двух клеток больше нуля, иначе выводить 
# соответствующее сообщение.

# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки
# определяется как произведение количества ячеек этих двух клеток.

# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки 
# определяется как целочисленное деление количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(), принимающий экземпляр
# класса и количество ячеек в ряду. Данный метод позволяет организовать 
# ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где
# количество ячеек между \n равно переданному аргументу. Если ячеек на 
# формирование ряда не хватает, то в последний ряд записываются все 
# оставшиеся.

# Например, количество ячеек клетки равняется 12, количество ячеек в 
# ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. 
# Тогда метод make_order() вернёт строку: *****\n*****\n*****.

class Cell:
    def __init__(self, lot=1):
        self.lot = int(lot) if lot > 0 else 1

    def __add__(self, other):
        self.lot += other.lot
        return f"Число ячеек объединенной клетки {self.lot}"

    def __sub__(self, other):
        if other.lot < self.lot:
            self.lot -= other.lot
            return f"Число ячеек уменьшенной клетки {self.lot}"
        else:
            return f"невозможно уменьшить на данное количество ячеек"

    def __mul__(self, other):
        self.lot *= other.lot
        return f"Число ячеек объединенной клетки {self.lot}"

    def __truediv__(self, other):
        if other.lot > 0:
            self.lot //= other.lot
            return f"Число ячеек уменьшенной клетки {self.lot}"
        else:
            return f"Невозможно уменьшить на данное количество ячеек"

    def make_order(self, size):
        cell_str = [("*" * size) + r"\n" for i in range(int(self.lot / size))]
        cell_str += "*" * int(self.lot % size)
        return "".join(cell_str)

seed_1 = Cell(32)
seed_2 = Cell(8)
seed_3 = Cell(12)
seed_4 = Cell(7)
seed_5 = Cell(25)
print(seed_2 - seed_3)
print(seed_1 / seed_4)
print(seed_2 + seed_3)
print(seed_5 - seed_2)
print(seed_1 * seed_5)
print(seed_1.make_order(7))
print(Cell(0).make_order(8))
